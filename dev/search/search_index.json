{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Zora documentation","text":"<p>This documentation will help you install, explore, and configure Zora!</p>"},{"location":"#what-is-zora","title":"What is Zora?","text":"<p>Zora is an open-source solution that helps you achieve compliance with Kubernetes best practices recommended by  industry-leading frameworks.</p> <p>By scanning your cluster with multiple plugins at scheduled times,  Zora identifies potential issues, misconfigurations, and vulnerabilities.</p>"},{"location":"#zora-oss-vs-zora-dashboard","title":"Zora OSS vs Zora Dashboard","text":"<p>Zora OSS is open-source, available under Apache 2.0 license, and can be used either as standalone tool or integrated with Zora Dashboard,  a SaaS platform which centralize all your clusters providing a full experience.  Please refer to Zora Dashboard page for more details.</p>"},{"location":"#key-features","title":"Key features","text":""},{"location":"#multi-plugin-architecture","title":"Multi-plugin architecture","text":"<p>Zora seamlessly integrates open-source tools like  Popeye,  Marvin,  and Trivy as scanners.  These tools' capabilities are combined to provide you with a unified view of your cluster's security posture,  addressing potential issues, misconfigurations, and vulnerabilities.</p>"},{"location":"#kubernetes-compliance","title":"Kubernetes compliance","text":"<p>Zora and its plugins provide actionable insights, guiding you to align your cluster with industry-recognized frameworks  such as  NSA-CISA,  MITRE ATT&amp;CK,  CIS Benchmark,  and Pod Security Standards.</p>"},{"location":"#custom-checks","title":"Custom checks","text":"<p>Enabled by the Marvin plugin, Zora offers a declarative way to create your own  checks by using Common Expression Language (CEL) expressions to define validation rules.</p>"},{"location":"#kubernetes-native","title":"Kubernetes-native","text":"<p>All scan configurations and plugin reports, including misconfigurations and vulnerabilities, are securely stored as CRDs (Custom Resource Definitions) within your Kubernetes cluster, making it easily accessible through the Kubernetes API and <code>kubectl</code> command.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>Zora works as a Kubernetes Operator,  where both scan and plugin configurations, as well as the results (misconfigurations and vulnerabilities),  are managed in CRDs (Custom Resource Definitions).</p> <p> </p> <p>Zora Dashboard</p> <p>When a Zora OSS installation is integrated with Zora Dashboard,  scan results are automatically sent to Zora Dashboard SaaS by <code>zora-operator</code>.</p> <p>Check out Zora Dashboard architecture for more details.</p>"},{"location":"#zora-origins","title":"Zora origins","text":"<p>In the early days of the cloud native era, Borg  dominated the container-oriented cluster management scene. The origin of the name Borg refers to the cybernetic life form existing in the Star Trek series, that worked as a collective of individuals with a single mind and the same purpose, as well as a \"cluster\".</p> <p>As good nerds as we are and wishing to honor our Kubernetes'  predecessor (Borg) we named our project Zora.</p> <p>In Star Trek, Zora is the Artificial Intelligence that controls the ship U.S.S Discovery. After being merged with a collective of other intelligences, Zora became sentient and became a member of the team,  bringing insights and making the ship more efficient.</p> <p>Like Star Trek's Zora, our goal is to help manage your Kubernetes environment by combining multiple plugin capabilities to scan your clusters looking for misconfigurations and vulnerabilities.</p>"},{"location":"dashboard/","title":"Zora Dashboard","text":"<p>Zora Dashboard is a SaaS platform designed to seamlessly centralize the security posture management of all your Kubernetes clusters, providing a full experience powered by Zora OSS.</p> <p>It features a powerful UI that allows you to navigate, filter and explore details of issues and affected resources across all your clusters. You can also invite users to your workspace.</p> <p></p> Try Zora Dashboard <p>Currently, it's free for up to 3 clusters. Please contact us if you need unlock more clusters in Zora Dashboard.</p>"},{"location":"dashboard/#getting-started","title":"Getting started","text":"<p>To integrate your cluster with Zora Dashboard, you need to provide the workspace ID as an additional parameter in Zora OSS installation command.</p> <ol> <li>Sign in at Zora Dashboard;</li> <li>Click on \"Connect cluster\" button and copy the workspace ID;</li> <li>Then provide it in <code>saas.workspaceID</code> parameter in Zora OSS installation command:</li> </ol> HTTP chart repositoryOCI registry <pre><code>helm repo add undistro https://charts.undistro.io --force-update\nhelm repo update undistro\nhelm upgrade --install zora undistro/zora \\\n  -n zora-system \\\n  --version 0.9.2 \\\n  --create-namespace \\\n  --wait \\\n  --set clusterName=\"$(kubectl config current-context)\" \\\n  --set saas.workspaceID=&lt;YOUR WORKSPACE ID HERE&gt;\n</code></pre> <pre><code>helm upgrade --install zora oci://ghcr.io/undistro/helm-charts/zora \\\n  -n zora-system \\\n  --version 0.9.2 \\\n  --create-namespace \\\n  --wait \\\n  --set clusterName=\"$(kubectl config current-context)\" \\\n  --set saas.workspaceID=&lt;YOUR WORKSPACE ID HERE&gt;\n</code></pre>"},{"location":"dashboard/#architecture","title":"Architecture","text":"<p>Zora OSS acts as the engine of Zora Dashboard, meaning that once scans are completed, only the results are sent to Zora Dashboard, where they are accessible by you and those you have invited to your workspace.</p> <p> </p> <p>Note that these results do not contain sensitive information or specific data about your cluster configuration.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Do you have any question about Zora? We do our best to answer all of your questions on this page.  If you can't find your question below,  ask it on our discussion board!</p>"},{"location":"faq/#is-zora-open-source","title":"Is Zora open source?","text":"<p>There are two Zora tools: Zora OSS and Zora Dashboard.</p> <p>Zora OSS is open-source, available under Apache 2.0 license,  and can be used either as standalone tool or integrated with Zora Dashboard.</p> <p>On the other hand, Zora Dashboard is a SaaS platform that provides a full experience,  centralizing the security posture management of all your clusters. It's free for up to 3 clusters. Visit the Zora Dashboard page for more information.</p>"},{"location":"faq/#can-i-use-zora-oss-standalone-without-zora-dashboard","title":"Can I use Zora OSS standalone without Zora Dashboard?","text":"<p>Yes, you can use Zora OSS as a standalone tool and access scan results (misconfigurations and vulnerabilities)  via <code>kubectl</code> one cluster at a time.</p>"},{"location":"faq/#can-i-install-zora-in-a-different-namespace","title":"Can I install Zora in a different namespace?","text":"<p>Yes, Zora can be installed in any namespace.  Simply provide the namespace name using the <code>-n</code> flag in Helm installation command.</p> <p>The <code>Cluster</code>, <code>ClusterScan</code>, <code>Plugin</code>, <code>ClusterIssue</code>, and <code>VulnerabilityReport</code> objects  will be created in the specified namespace.</p> <p>If you already have Zora installed and want to change the namespace, you will need to reinstall it.</p>"},{"location":"faq/#can-i-integrate-my-own-plugins-with-zora-and-how","title":"Can I integrate my own plugins with Zora, and how?","text":"<p>Currently, integrating a new plugin into Zora requires modifying the source code of Worker, a Zora component. The parsing of plugin results into <code>ClusterIssue</code> or <code>VulnerabilityReport</code> is directly handled by Worker,  which is written in Go. A fully declarative approach is not yet supported.</p> <p>Refer to plugins page to know more about how plugins work.</p> <p>Feel free to open an issue or  start a discussion with any suggestions  regarding this process.</p>"},{"location":"faq/#which-data-is-sent-to-zora-dashboard-saas","title":"Which data is sent to Zora Dashboard (SaaS)?","text":"<p>When integrated with Zora Dashboard, only scan results are sent to the SaaS platform. </p> <p>No sensitive information is collected or exposed. </p> <p>Scans are performed in your cluster and the results are securely sent via HTTPS to Zora Dashboard,  where only you and the users you've invited to your workspace will have access.</p>"},{"location":"faq/#can-i-host-zora-dashboard-on-premise","title":"Can I host Zora Dashboard on-premise?","text":"<p>Currently, Zora Dashboard is available as a SaaS platform.  While we do not offer an on-premise version of Zora Dashboard at this time, we're continuously working to enhance and  expand our offerings. If you have specific requirements or are interested in on-premise solutions,  please contact us, and we'll be happy to discuss potential options and  explore how we can meet your needs.</p>"},{"location":"helm-chart/","title":"Zora Helm Chart","text":"<p>A multi-plugin solution that reports misconfigurations and vulnerabilities by scanning your cluster at scheduled times.</p>"},{"location":"helm-chart/#installing-the-chart","title":"Installing the Chart","text":"<p>To install the chart with the release name <code>zora</code> in <code>zora-system</code> namespace:</p> <pre><code>helm repo add undistro https://charts.undistro.io --force-update\nhelm repo update undistro\nhelm upgrade --install zora undistro/zora \\\n  -n zora-system \\\n  --version 0.9.3-rc1 \\\n  --create-namespace \\\n  --wait \\\n  --set clusterName=\"$(kubectl config current-context)\"\n</code></pre> <p>These commands deploy Zora on the Kubernetes cluster with the default configuration.</p> <p>The Parameters section lists the available parameters that can be configured during installation.</p> <p>Tips:</p> <ul> <li> <p>List all charts available in <code>undistro</code> repo using <code>helm search repo undistro</code></p> </li> <li> <p>Update <code>undistro</code> chart repository using <code>helm repo update undistro</code></p> </li> <li> <p>List all versions available of <code>undistro/zora</code> chart using <code>helm search repo undistro/zora --versions</code></p> </li> <li> <p>List all releases in a specific namespace using <code>helm list -n zora-system</code></p> </li> <li> <p>Get the notes provided by <code>zora</code> release using <code>helm get notes zora -n zora-system</code></p> </li> </ul>"},{"location":"helm-chart/#uninstalling-the-chart","title":"Uninstalling the Chart","text":"<p>To uninstall/delete the <code>zora</code> release:</p> <pre><code>helm uninstall zora -n zora-system\n</code></pre> <p>The command removes all the Kubernetes components associated with the chart and deletes the release.</p>"},{"location":"helm-chart/#parameters","title":"Parameters","text":"<p>The following table lists the configurable parameters of the Zora chart and their default values.</p> Key Type Default Description nameOverride string <code>\"\"</code> String to partially override fullname template with a string (will prepend the release name) fullnameOverride string <code>\"\"</code> String to fully override fullname template with a string clusterName string <code>\"\"</code> Cluster name. Should be set by <code>kubectl config current-context</code>. saas.workspaceID string <code>\"\"</code> Your SaaS workspace ID saas.server string <code>\"https://zora-dashboard.undistro.io\"</code> SaaS server URL saas.installURL string <code>\"{{.Values.saas.server}}/zora/api/v1alpha1/workspaces/{{.Values.saas.workspaceID}}/helmreleases\"</code> SaaS URL template to notify installation hooks.install.image.repository string <code>\"curlimages/curl\"</code> Post-install hook image repository hooks.install.image.tag string <code>\"8.7.1\"</code> Post-install hook image tag hooks.delete.image.repository string <code>\"rancher/kubectl\"</code> Pre-delete hook image repository hooks.delete.image.tag string <code>\"v1.29.2\"</code> Pre-delete hook image tag imageCredentials.create bool <code>false</code> Specifies whether the secret should be created by providing credentials imageCredentials.registry string <code>\"ghcr.io\"</code> Docker registry host imageCredentials.username string <code>\"\"</code> Docker registry username imageCredentials.password string <code>\"\"</code> Docker registry password imagePullSecrets list <code>[]</code> Specify docker-registry secret names as an array to be used when <code>imageCredentials.create</code> is false operator.replicaCount int <code>1</code> Number of replicas desired of Zora operator operator.image.repository string <code>\"ghcr.io/undistro/zora/operator\"</code> Zora operator image repository operator.image.tag string <code>\"\"</code> Overrides the image tag whose default is the chart appVersion operator.image.pullPolicy string <code>\"IfNotPresent\"</code> Image pull policy operator.rbac.create bool <code>true</code> Specifies whether ClusterRoles and ClusterRoleBindings should be created operator.rbac.serviceAccount.create bool <code>true</code> Specifies whether a service account should be created operator.rbac.serviceAccount.annotations object <code>{}</code> Annotations to be added to service account operator.rbac.serviceAccount.name string <code>\"\"</code> The name of the service account to use. If not set and create is true, a name is generated using the fullname template operator.podAnnotations object <code>{\"kubectl.kubernetes.io/default-container\":\"manager\"}</code> Annotations to be added to pods operator.podSecurityContext object <code>{\"runAsNonRoot\":true}</code> Security Context to add to the pod operator.securityContext object <code>{\"allowPrivilegeEscalation\":false,\"readOnlyRootFilesystem\":true}</code> Security Context to add to <code>manager</code> container operator.metricsService.type string <code>\"ClusterIP\"</code> Type of metrics service operator.metricsService.port int <code>8443</code> Port of metrics service operator.serviceMonitor.enabled bool <code>false</code> Specifies whether a Prometheus <code>ServiceMonitor</code> should be enabled operator.resources object <code>{\"limits\":{\"cpu\":\"500m\",\"memory\":\"128Mi\"},\"requests\":{\"cpu\":\"10m\",\"memory\":\"64Mi\"}}</code> Resources to add to <code>manager</code> container operator.rbacProxy.image.repository string <code>\"gcr.io/kubebuilder/kube-rbac-proxy\"</code> <code>kube-rbac-proxy</code> image repository operator.rbacProxy.image.tag string <code>\"v0.15.0\"</code> <code>kube-rbac-proxy</code> image tag operator.rbacProxy.image.pullPolicy string <code>\"IfNotPresent\"</code> Image pull policy operator.rbacProxy.securityContext object <code>{\"allowPrivilegeEscalation\":false,\"capabilities\":{\"drop\":[\"ALL\"]},\"readOnlyRootFilesystem\":true}</code> Security Context to add to <code>kube-rbac-proxy</code> container operator.rbacProxy.resources object <code>{\"limits\":{\"cpu\":\"500m\",\"memory\":\"128Mi\"},\"requests\":{\"cpu\":\"5m\",\"memory\":\"64Mi\"}}</code> Resources to add to <code>kube-rbac-proxy</code> container operator.nodeSelector object <code>{}</code> Node selection to constrain a Pod to only be able to run on particular Node(s) operator.tolerations list <code>[]</code> Tolerations for pod assignment operator.affinity object <code>{}</code> Map of node/pod affinities operator.log.encoding string <code>\"json\"</code> Log encoding (one of 'json' or 'console') operator.log.level string <code>\"info\"</code> Log level to configure the verbosity of logging. Can be one of 'debug', 'info', 'error', or any integer value &gt; 0 which corresponds to custom debug levels of increasing verbosity operator.log.stacktraceLevel string <code>\"error\"</code> Log level at and above which stacktraces are captured (one of 'info', 'error' or 'panic') operator.log.timeEncoding string <code>\"rfc3339\"</code> Log time encoding (one of 'epoch', 'millis', 'nano', 'iso8601', 'rfc3339' or 'rfc3339nano') operator.webhook.enabled bool <code>true</code> Specifies whether webhook server is enabled scan.misconfiguration.enabled bool <code>true</code> Specifies whether misconfiguration scan is enabled scan.misconfiguration.schedule string Cron expression for every hour at the current minute + 5 minutes Cluster scan schedule in Cron format for misconfiguration scan scan.misconfiguration.successfulScansHistoryLimit int <code>1</code> The number of successful finished scans and their issues to retain. scan.misconfiguration.plugins list <code>[\"marvin\",\"popeye\"]</code> Misconfiguration scanners plugins scan.vulnerability.enabled bool <code>true</code> Specifies whether vulnerability scan is enabled scan.vulnerability.schedule string Cron expression for every day at the current hour and minute + 5 minutes Cluster scan schedule in Cron format for vulnerability scan scan.vulnerability.successfulScansHistoryLimit int <code>1</code> The number of successful finished scans and their issues to retain. scan.vulnerability.plugins list <code>[\"trivy\"]</code> Vulnerability scanners plugins scan.worker.image.repository string <code>\"ghcr.io/undistro/zora/worker\"</code> worker image repository scan.worker.image.tag string <code>\"\"</code> Overrides the image tag whose default is the chart appVersion scan.plugins.annotations object <code>{}</code> Annotations added to the plugin service account scan.plugins.marvin.resources object <code>{\"limits\":{\"cpu\":\"500m\",\"memory\":\"500Mi\"},\"requests\":{\"cpu\":\"250m\",\"memory\":\"256Mi\"}}</code> Resources to add to <code>marvin</code> container scan.plugins.marvin.podAnnotations object <code>{}</code> Annotations added to the marvin pods scan.plugins.marvin.image.repository string <code>\"ghcr.io/undistro/marvin\"</code> marvin plugin image repository scan.plugins.marvin.image.tag string <code>\"v0.2\"</code> marvin plugin image tag scan.plugins.marvin.image.pullPolicy string <code>\"Always\"</code> Image pull policy scan.plugins.marvin.env list <code>[]</code> List of environment variables to set in marvin container. scan.plugins.marvin.envFrom list <code>[]</code> List of sources to populate environment variables in marvin container. scan.plugins.trivy.ignoreUnfixed bool <code>false</code> Specifies whether only fixed vulnerabilities should be reported scan.plugins.trivy.ignoreDescriptions bool <code>false</code> Specifies whether vulnerability descriptions should be ignored scan.plugins.trivy.resources object <code>{}</code> Resources to add to <code>trivy</code> container scan.plugins.trivy.podAnnotations object <code>{}</code> Annotations added to the trivy pods scan.plugins.trivy.image.repository string <code>\"ghcr.io/undistro/trivy\"</code> trivy plugin image repository scan.plugins.trivy.image.tag float <code>0.53</code> trivy plugin image tag scan.plugins.trivy.image.pullPolicy string <code>\"Always\"</code> Image pull policy scan.plugins.trivy.env list <code>[]</code> List of environment variables to set in trivy container. scan.plugins.trivy.envFrom list <code>[]</code> List of sources to populate environment variables in trivy container. scan.plugins.trivy.timeout string <code>\"10m\"</code> Trivy timeout scan.plugins.trivy.insecure bool <code>false</code> Allow insecure server connections for Trivy scan.plugins.trivy.persistence.enabled bool <code>true</code> Specifies whether Trivy vulnerabilities database should be persisted between the scans, using PersistentVolumeClaim scan.plugins.trivy.persistence.fsGroup int <code>0</code> Specifies the fsGroup to use when mounting the persistent volume scan.plugins.trivy.persistence.accessMode string <code>\"ReadWriteOnce\"</code> Persistence access mode scan.plugins.trivy.persistence.storageClass string <code>\"\"</code> Persistence storage class. Set to empty for default storage class scan.plugins.trivy.persistence.storageRequest string <code>\"2Gi\"</code> Persistence storage size scan.plugins.trivy.persistence.downloadJavaDB bool <code>false</code> Specifies whether Java vulnerability database should be downloaded on helm install/upgrade scan.plugins.popeye.skipInternalResources bool <code>false</code> Specifies whether the following resources should be skipped by <code>popeye</code> scans. 1. resources from <code>kube-system</code>, <code>kube-public</code> and <code>kube-node-lease</code> namespaces; 2. kubernetes system reserved RBAC (prefixed with <code>system:</code>); 3. <code>kube-root-ca.crt</code> configmaps; 4. <code>default</code> namespace; 5. <code>default</code> serviceaccounts; 6. Helm secrets (prefixed with <code>sh.helm.release</code>); 7. Zora components. See <code>popeye</code> configuration file that is used for this case: https://github.com/undistro/zora/blob/main/charts/zora/templates/plugins/popeye-config.yaml scan.plugins.popeye.resources object <code>{\"limits\":{\"cpu\":\"500m\",\"memory\":\"500Mi\"},\"requests\":{\"cpu\":\"250m\",\"memory\":\"256Mi\"}}</code> Resources to add to <code>popeye</code> container scan.plugins.popeye.podAnnotations object <code>{}</code> Annotations added to the popeye pods scan.plugins.popeye.image.repository string <code>\"ghcr.io/undistro/popeye\"</code> popeye plugin image repository scan.plugins.popeye.image.tag float <code>0.21</code> popeye plugin image tag scan.plugins.popeye.image.pullPolicy string <code>\"Always\"</code> Image pull policy scan.plugins.popeye.env list <code>[]</code> List of environment variables to set in popeye container. scan.plugins.popeye.envFrom list <code>[]</code> List of sources to populate environment variables in popeye container. kubexnsImage.repository string <code>\"ghcr.io/undistro/kubexns\"</code> kubexns image repository kubexnsImage.tag string <code>\"v0.1\"</code> kubexns image tag kubexnsImage.pullPolicy string <code>\"Always\"</code> Image pull policy customChecksConfigMap string <code>\"zora-custom-checks\"</code> Custom checks ConfigMap name httpsProxy string <code>\"\"</code> HTTPS proxy URL noProxy string <code>\"kubernetes.default.svc.*,127.0.0.1,localhost\"</code> Comma-separated list of URL patterns to be excluded from going through the proxy updateCRDs bool <code>true</code> for upgrades Specifies whether CRDs should be updated by operator at startup <p>Specify each parameter using the <code>--set key=value[,key=value]</code> argument to <code>helm install</code>. For example,</p> <pre><code>helm install zora \\\n  --set operator.resources.limits.memory=256Mi undistro/zora\n</code></pre> <p>Alternatively, a YAML file that specifies the values for the parameters can be provided while installing the chart. For example,</p> <pre><code>helm install zora -f values.yaml undistro/zora\n</code></pre> <p>Tip: You can use the default values.yaml</p>"},{"location":"configuration/authenticated-registries/","title":"Authenticated Registries","text":"<p>Trivy plugin is able to scan images from registries that require authentication.</p> <p>It's necessary to create a secret containing authentication credentials as pairs, like the command below.</p> <p>Note</p> <p>For AWS ECR and Azure ACR registries, please refer to the specific pages.</p> <pre><code>kubectl create secret generic trivy-credentials -n zora-system \\\n  --from-literal=TRIVY_USERNAME=\"&lt;username1&gt;,&lt;username2&gt;\" \\\n  --from-literal=TRIVY_PASSWORD=\"&lt;password1&gt;,&lt;password2&gt;\"\n</code></pre> <p>Note</p> <p>Please note that the number of usernames and passwords must be the same.</p> <p>Once the secret is created, it needs to be referenced in the Helm chart parameters as the following <code>values.yaml</code> file:</p> <pre><code>scan:\n  plugins:\n    trivy:\n      envFrom:\n        - secretRef:\n            name: trivy-credentials\n            optional: true\n</code></pre> <p>Then provide this file in <code>helm upgrade --install</code> command with <code>-f values.yaml</code> flag.</p> <p>This ensures that Trivy can authenticate with the private registries using the provided credentials.</p>"},{"location":"configuration/custom-checks/","title":"Custom checks","text":"<p>Zora offers a declarative way to create your own checks using the <code>CustomCheck</code> API, introduced in version 0.6.</p> <p>Custom checks use the Common Expression Language (CEL)  to declare the validation rules and are performed by the Marvin plugin,  which should be enabled in your cluster scans.</p> <p>Info</p> <p>Marvin is already a default plugin and enabled by default in cluster scans since Zora 0.5.0.</p>"},{"location":"configuration/custom-checks/#customcheck-api","title":"<code>CustomCheck</code> API","text":"<p>The example below demonstrates a custom check that requires the labels <code>mycompany.com/squad</code> and <code>mycompany.com/component</code>  to be present on <code>Pods</code>, <code>Deployments</code> and <code>Services</code>.</p> <p>Example</p> <pre><code>apiVersion: zora.undistro.io/v1alpha1\nkind: CustomCheck\nmetadata:\n  name: mycheck\nspec:\n  message: \"Required labels\"\n  severity: Low\n  category: Custom\n  match:\n    resources:\n      - group: \"\"\n        version: v1\n        resource: pods\n      - group: apps\n        version: v1\n        resource: deployments\n      - group: \"\"\n        version: v1\n        resource: services\n  params:\n    requiredLabels:\n      - mycompany.com/squad\n      - mycompany.com/component\n  validations:\n    - expression: &gt;\n        has(object.metadata.labels) &amp;&amp;\n        !object.metadata.labels.all(label,\n          params.requiredLabels.all(\n            req, req != label\n          )\n        )\n      message: \"Resource without required labels\"\n</code></pre> <p>The <code>spec.match.resources</code> defines which resources are checked by the expressions  defined in <code>spec.validations.expression</code> using Common Expression Language (CEL).</p> <p>If an expression evaluates to <code>false</code>, the check fails, and a <code>ClusterIssue</code> is reported.</p> <p>CEL Playground</p> <p>To quickly test CEL expressions directly from your browser, check out CEL Playground.</p>"},{"location":"configuration/custom-checks/#variables","title":"Variables","text":"<p>The variables available in CEL expressions:</p> Variable Description <code>object</code> The object being scanned. <code>params</code> The parameter defined in <code>spec.params</code> field. <p>If the object matches a <code>PodSpec</code>, the following useful variables are available:</p> Variable Description <code>allContainers</code> A list of all containers, including <code>initContainers</code> and <code>ephemeralContainers</code>. <code>podMeta</code> The Pod <code>metadata</code>. <code>podSpec</code> The Pod <code>spec</code>. <p>The following resources matches a <code>PodSpec</code>:</p> <ul> <li><code>v1/pods</code></li> <li><code>v1/replicationcontrollers</code></li> <li><code>apps/v1/replicasets</code></li> <li><code>apps/v1/deployments</code></li> <li><code>apps/v1/statefulsets</code></li> <li><code>apps/v1/daemonsets</code></li> <li><code>batch/v1/jobs</code></li> <li><code>batch/v1/cronjobs</code></li> </ul>"},{"location":"configuration/custom-checks/#applying-custom-checks","title":"Applying custom checks","text":"<p>Since you have a <code>CustomCheck</code> on a file, you can apply it with the following command.</p> <pre><code>kubectl apply -f check.yaml -n zora-system\n</code></pre>"},{"location":"configuration/custom-checks/#listing-custom-checks","title":"Listing custom checks","text":"<p>Once created, list the custom checks to see if they are ready.</p> <p><pre><code>kubectl get customchecks -n zora-system\n</code></pre> <pre><code>NAME      MESSAGE           SEVERITY   READY\nmycheck   Required labels   Low        True\n</code></pre></p> <p>The <code>READY</code> column indicates when the check has successfully compiled and is ready to be used in the next Marvin scan.</p> <p><code>ClusterIssues</code> reported by a custom check are labeled <code>custom=true</code> and can be filtered by the following command:</p> <p><pre><code>kubectl get clusterissues -l custom=true\n</code></pre> <pre><code>NAME                             CLUSTER     ID        MESSAGE           SEVERITY   CATEGORY   AGE\nmycluster-mycheck-4edd75cb85a4   mycluster   mycheck   Required labels   Low        Custom     25s\n</code></pre></p>"},{"location":"configuration/custom-checks/#examples","title":"Examples","text":"<p>All Marvin checks are similar to the <code>CustomCheck</code> API.  You can see them in the <code>internal/builtins</code> folder for examples.</p> <p>Here are some examples of Marvin built-in checks expressions:</p> <ul> <li>HostPath volumes must be forbidden <pre><code>!has(podSpec.volumes) || podSpec.volumes.all(vol, !has(vol.hostPath))\n</code></pre></li> <li>Sharing the host namespaces must be disallowed <pre><code>(!has(podSpec.hostNetwork) || podSpec.hostNetwork == false) &amp;&amp;\n(!has(podSpec.hostPID) || podSpec.hostPID == false) &amp;&amp;\n(!has(podSpec.hostIPC) || podSpec.hostIPC == false)\n</code></pre></li> <li>Privileged Pods disable most security mechanisms and must be disallowed <pre><code>allContainers.all(container,\n  !has(container.securityContext) ||\n  !has(container.securityContext.privileged) ||\n  container.securityContext.privileged == false)\n</code></pre></li> <li>HostPorts should be disallowed entirely (recommended) or restricted to a known list <pre><code>allContainers.all(container,\n  !has(container.ports) ||\n  container.ports.all(port,\n    !has(port.hostPort) ||\n    port.hostPort == 0 ||\n    port.hostPort in params.allowedHostPorts\n  )\n)\n</code></pre></li> </ul> <p>Marvin's checks and Zora's <code>CustomCheck</code> API are inspired in  Kubernetes ValidatingAdmissionPolicy API,  introduced in version 1.26 as an alpha feature.  Below, the table of validation expression examples from Kubernetes documentation.</p> Expression Purpose <code>object.minReplicas &lt;= object.replicas &amp;&amp; object.replicas &lt;= object.maxReplicas</code> Validate that the three fields defining replicas are ordered appropriately <code>'Available' in object.stateCounts</code> Validate that an entry with the 'Available' key exists in a map <code>(size(object.list1) == 0) != (size(object.list2) == 0)</code> Validate that one of two lists is non-empty, but not both <code>!('MY_KEY' in object.map1) || object['MY_KEY'].matches('^[a-zA-Z]*$')</code> Validate the value of a map for a specific key, if it is in the map <code>object.envars.filter(e, e.name == 'MY_ENV').all(e, e.value.matches('^[a-zA-Z]*$')</code> Validate the 'value' field of a listMap entry where key field 'name' is 'MY_ENV' <code>has(object.expired) &amp;&amp; object.created + object.ttl &lt; object.expired</code> Validate that 'expired' date is after a 'create' date plus a 'ttl' duration <code>object.health.startsWith('ok')</code> Validate a 'health' string field has the prefix 'ok' <code>object.widgets.exists(w, w.key == 'x' &amp;&amp; w.foo &lt; 10)</code> Validate that the 'foo' property of a listMap item with a key 'x' is less than 10 <code>type(object) == string ? object == '100%' : object == 1000</code> Validate an int-or-string field for both the int and string cases <code>object.metadata.name.startsWith(object.prefix)</code> Validate that an object's name has the prefix of another field value <code>object.set1.all(e, !(e in object.set2))</code> Validate that two listSets are disjoint <code>size(object.names) == size(object.details) &amp;&amp; object.names.all(n, n in object.details)</code> Validate the 'details' map is keyed by the items in the 'names' listSet <code>size(object.clusters.filter(c, c.name == object.primary)) == 1</code> Validate that the 'primary' property has one and only one occurrence in the 'clusters' listMap"},{"location":"configuration/https-proxy/","title":"HTTPS Proxy","text":"<p>If your network environment requires the use of a proxy, you must ensure proper configuration of the <code>httpsProxy</code> parameter when running <code>helm upgrade --install</code> command.</p> <pre><code># omitted \"helm upgrade --install\" command and parameters\n\n--set httpsProxy=\"https://secure.proxy.tld\"\n</code></pre> <p>Additionally, you can specify URLs that should bypass the proxy, by setting the <code>noProxy</code> parameter in comma-separated  list format. Note that this parameter already has a default value: <code>kubernetes.default.svc.*,127.0.0.1,localhost</code>.</p> <p>Configuring proxy settings enables both <code>trivy</code> plugin and <code>zora-operator</code> to use the proxy for external requests.</p> <p>Zora OSS sends scan results to the following external URL if your installation is integrated with Zora Dashboard:</p> <ul> <li><code>https://zora-dashboard.undistro.io</code></li> </ul> <p>While Trivy downloads vulnerability databases during scans from the following external sources:</p> <ul> <li><code>ghcr.io/aquasecurity/trivy-db</code> </li> <li><code>ghcr.io/aquasecurity/trivy-java-db</code></li> </ul>"},{"location":"configuration/resources/","title":"Compute resources","text":"<p>Zora Helm Chart allows you to define resource requests and limits (memory and CPU)  for <code>zora-operator</code> and plugins. You can do this by setting specific parameters using <code>--set</code> argument as the example below.</p> <pre><code>--set operator.resources.limits.memory=256Mi\n</code></pre> <p>Alternatively, a YAML file can be specified using <code>-f myvalues.yaml</code> flag.</p> <p>Tip</p> <p>Refer to the default values.yaml file for more details</p> <p>In a similar way, you can customize the resources for plugins. The following example sets <code>1Gi</code> as memory limit for <code>marvin</code> plugin.</p> <pre><code>--set scan.plugins.marvin.resources.limits.memory=1Gi\n</code></pre>"},{"location":"configuration/retain-issues/","title":"Retain issues","text":"<p>By default, both scans automatically scheduled by Zora upon installation  are configured to retain issues/results only from the last scan.</p> <p>To retain results from the last two scans, for example,  you should set the <code>successfulScansHistoryLimit</code> field of <code>ClusterScan</code> to <code>2</code>.</p> <p>This can be done by either directly editing the <code>ClusterScan</code> object  or by providing a parameter in the Helm installation/upgrade command, </p> <pre><code># omitted \"helm upgrade --install\" command and parameters\n\n--set scan.misconfiguration.successfulScansHistoryLimit=2\n</code></pre> <p>In this case, it may appear that there are duplicate issues when more than one scan completes successfully.  However, these issues are actually related to different scans.  The identifier of each scan can be found in the <code>scanID</code> label of each issue.</p> <p><pre><code>kubectl get issues -n zora-system --show-labels\n</code></pre> <pre><code>NAME                    CLUSTER     ID      MESSAGE                SEVERITY   CATEGORY   AGE    LABELS\nkind-kind-m-102-4wxvv   kind-kind   M-102   Privileged container   High       Security   43s    scanID=556cc35a-830e-45af-a31c-7130918de262,category=Security,cluster=kind-kind,custom=false,id=M-102,plugin=marvin,severity=High\nkind-kind-m-102-nf5xq   kind-kind   M-102   Privileged container   High       Security   102s   scanID=8464411a-4b9c-456b-a11c-dd3a5ab905f5,category=Security,cluster=kind-kind,custom=false,id=M-102,plugin=marvin,severity=High\n</code></pre></p> <p>To list issues from a specific scan, you can use a label selector like this:</p> <pre><code>kubectl get issues -n zora-system -l scanID=556cc35a-830e-45af-a31c-7130918de262\n</code></pre> <p>This also applies to vulnerability scans and <code>VulnerabilityReport</code> results.</p> <p>Warning</p> <p>Note that results are stored as CRDs in your Kubernetes cluster.  Be cautious not to set a high value that could potentially affect  the performance and storage capacity of your Kubernetes cluster</p> <p>Note</p> <p>That applies only to Zora OSS. Zora Dashboard always shows results from the last scan.</p>"},{"location":"configuration/scan-schedule/","title":"Scan schedule","text":"<p>After successfully installing Zora, vulnerability and misconfiguration scans are  automatically scheduled for your cluster, with each scan using different plugins.</p> <p>Scan schedules are defined using Cron expressions.  You can view the schedule for your cluster by listing <code>ClusterScan</code> resources:</p> <pre><code>kubectl get clusterscans -o wide -n zora-system\n</code></pre> <p>By default, the misconfiguration scan is scheduled to run every hour at the current minute plus 5,  while the vulnerability scan is scheduled to run every day at the current hour and the current minute plus 5.</p> <p>For example, if the installation occurred at 10:00 UTC, the scans will have the following schedules:</p> Scan Cron Description Misconfigurations <code>5 * * * *</code> Every hour at minute 5 Vulnerabilities <code>5 10 * * *</code> Every day at 10:05 <p>However, you can customize the schedule for each scan  by directly editing the <code>ClusterScan</code> resource  or by providing parameters in the <code>helm upgrade --install</code> command, as shown in the example below:</p> <pre><code># omitted \"helm upgrade --install\" command and parameters\n\n--set scan.misconfiguration.schedule=\"0 * * * *\" \\\n--set scan.vulnerability.schedule=\"0 0 * * *\"\n</code></pre> <p>The recommended approach is to provide parameters through Helm.</p> <p>Costly scan scheduling</p> <p>Overly frequent scheduling of scans can increase networking costs significantly,  especially for vulnerability scans, which involve downloading a vulnerability database and pulling images.</p> <p>Warning</p> <p>If you directly edit the <code>ClusterScan</code> resource, be cautious when running the next update via Helm, as the value may be overwritten.</p>"},{"location":"configuration/scan-schedule/#cron-schedule-syntax","title":"Cron schedule syntax","text":"<p>Cron expression has five fields separated by a space, and each field represents a time unit.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59)\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n\u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the month (1 - 31)\n\u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n\u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the week (0 - 6) (Sunday to Saturday;\n\u2502 \u2502 \u2502 \u2502 \u2502                                   7 is also Sunday on some systems)\n\u2502 \u2502 \u2502 \u2502 \u2502                                   OR sun, mon, tue, wed, thu, fri, sat\n\u2502 \u2502 \u2502 \u2502 \u2502\n* * * * *\n</code></pre> Operator Descriptor Example * Any value <code>15 * * * *</code> runs at every minute 15 of every hour of every day. , Value list separator <code>2,10 4,5 * * *</code> runs at minute 2 and 10 of the 4th and 5th hour of every day. - Range of values <code>30 4-6 * * *</code> runs at minute 30 of the 4th, 5th, and 6th hour. / Step values <code>20/15 * * * *</code> runs every 15 minutes starting from minute 20 through 59 (minutes 20, 35, and 50)."},{"location":"configuration/suspend-scan/","title":"Suspending scans","text":"<p>The cluster scans, which are automatically scheduled upon installation,  can be suspended by setting <code>spec.suspend</code> to <code>true</code> in a <code>ClusterScan</code> object.  This action will suspend subsequent scans, it does not apply to already started scans.</p> <p>The command below suspends the <code>mycluster-vuln</code> scan.</p> <pre><code>kubectl patch scan mycluster-vuln --type='merge' -p '{\"spec\":{\"suspend\":true}}' -n zora-system\n</code></pre> <p>Note</p> <p>This way, the scan results remain available,  unlike if the <code>ClusterScan</code> had been deleted, in which case the results would also be removed.</p> <p>Setting <code>spec.suspend</code> back to <code>false</code>, the scans are resume:</p> <pre><code>kubectl patch scan mycluster-vuln --type='merge' -p '{\"spec\":{\"suspend\":false}}' -n zora-system\n</code></pre>"},{"location":"configuration/vulnerability-database-persistence/","title":"Vulnerability Database Persistence","text":"<p>Trivy utilizes a database containing vulnerability information in its scan.  This database is updated every 6 hours.</p> <p>When scanning JAR files, Trivy downloads a specific database for Java every 3 days.</p> <p>Both databases are distributed via GitHub Container registry (GHCR) and cached  by Trivy in local file system.</p> <p>Starting with version 0.8.4, Zora persists Trivy databases by default, caching them between the scheduled scans.  This means that scheduled scans may not need to download the databases, saving compute resources, time, and networking.</p> <p>It's done by applying a PersistentVolumeClaim during  a Zora installation/upgrade through Helm. A Job is also applied, which just downloads the vulnerability database to be  ready for the first scheduled scan.</p> <p>This persistence can be disabled or configured with the following Helm parameters:</p> Key Type Default Description scan.plugins.trivy.persistence.enabled bool <code>true</code> Specifies whether Trivy vulnerabilities database should be persisted between the scans, using PersistentVolumeClaim scan.plugins.trivy.persistence.accessMode string <code>\"ReadWriteOnce\"</code> Persistence access mode scan.plugins.trivy.persistence.storageClass string <code>\"\"</code> Persistence storage class. Set to empty for default storage class scan.plugins.trivy.persistence.storageRequest string <code>\"2Gi\"</code> Persistence storage size scan.plugins.trivy.persistence.downloadJavaDB bool <code>false</code> Specifies whether Java vulnerability database should be downloaded on helm install/upgrade <p>These parameters can be specified using the <code>--set key=value</code> argument in <code>helm upgrade --install</code> command.</p>"},{"location":"configuration/private-registries/acr/","title":"Azure Container Registry (ACR)","text":"<p>If you are running within Azure, and making use of a private Azure Container Registry (ACR) to host your application images, then the Trivy plugin will be unable to scan those images unless access is granted to  the registry through a service principal with <code>AcrPull</code> role assigned.</p>"},{"location":"configuration/private-registries/acr/#creating-service-principal","title":"Creating service principal","text":"<p>The following Azure CLI command creates a service principal  with <code>AcrPull</code> role assigned, and stores the output including the credentials into <code>SP_DATA</code> environment variable.</p> <p>Note</p> <p>Please replace <code>&lt;SUBSCRIPTION_ID&gt;</code>, <code>&lt;RESOURCE_GROUP&gt;</code>, and <code>&lt;REGISTRY_NAME&gt;</code> before running the command below.</p> <pre><code>export SP_DATA=$(az ad sp create-for-rbac --name ZoraTrivy --role AcrPull --scope \"/subscriptions/&lt;SUBSCRIPTION_ID&gt;/resourceGroups/&lt;RESOURCE_GROUP&gt;/providers/Microsoft.ContainerRegistry/registries/&lt;REGISTRY_NAME&gt;\")\n</code></pre>"},{"location":"configuration/private-registries/acr/#usage","title":"Usage","text":"<p>Once the service principal is created and the credentials are in <code>SP_DATA</code> environment variable, create a Kubernetes secret to store these credentials by running:</p> <pre><code>kubectl create secret generic trivy-acr-credentials -n zora-system \\\n  --from-literal=AZURE_CLIENT_ID=$(echo $SP_DATA | jq -r '.appId') \\\n  --from-literal=AZURE_CLIENT_SECRET=$(echo $SP_DATA | jq -r '.password') \\\n  --from-literal=AZURE_TENANT_ID=$(echo $SP_DATA | jq -r '.tenant')\n</code></pre> <p>Note</p> <p>If you are running this command before a Zora installation, you may need to create the <code>zora-system</code> namespace. <pre><code>kubectl create namespace zora-system\n</code></pre></p> <p>Now set the secret name in a <code>values.yaml</code></p> <pre><code>scan:\n  plugins:\n    trivy:\n      envFrom:\n        - secretRef:\n            name: trivy-acr-credentials\n            optional: true\n</code></pre> <p>Then provide it in <code>helm upgrade --install</code> command</p> <pre><code>-f values.yaml\n</code></pre> <p>This will now allow the Trivy plugin to scan your internal images for vulnerabilities.</p>"},{"location":"configuration/private-registries/ecr/","title":"AWS Elastic Container Registry (ECR)","text":"<p>If you are running within AWS, and making use of a private Elastic Container Registry (ECR) to host your application images, then the Trivy plugin will be unable to scan those images unless access is granted to the registry through an Identity and Access Managemnent (IAM) role assigned to the service account running the Trivy plugins.</p> <p>Once an IAM role granting access to the ECR has been created, this can be assigned to the service account by including the following additional parameter when running the <code>helm upgrade --install</code> command.</p> <p><pre><code>--set scan.plugins.annotations.eks\\\\.amazonaws\\\\.com/role-arn=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;ROLE_NAME&gt;\n</code></pre> where <code>&lt;AWS_ACCOUNT_ID&gt;</code> should be replaced with your AWS account ID, and <code>&lt;ROLE_NAME&gt;</code> should be replaced with the name of the role granting access to the ECR.</p> <p>This will now allow the Trivy plugin to scan your internal images for vulnerabilities.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Zora OSS is installed inside your Kubernetes clusters using Helm, where the <code>zora-operator</code> deployment is created and scans are automatically scheduled for your cluster.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster 1.21+</li> <li>Kubectl</li> <li>Helm 3.8+</li> </ul>"},{"location":"getting-started/installation/#install-with-helm","title":"Install with Helm","text":"<p>First, ensure that your current context of <code>kubectl</code> refer to the Kubernetes cluster you wish to install Zora into.</p> Manage kubectl contexts <p>The following commands can help you to manage kubectl contexts:</p> <ul> <li> <p>List all contexts: <code>kubectl config get-contexts</code></p> </li> <li> <p>Display the current-context: <code>kubectl config current-context</code></p> </li> <li> <p>Use the context for the Kind cluster: <code>kubectl config use-context kind-kind</code></p> </li> </ul> <p>Then, run the following command to install Zora Helm chart:</p> HTTP chart repositoryOCI registry <pre><code>helm repo add undistro https://charts.undistro.io --force-update\nhelm repo update undistro\nhelm upgrade --install zora undistro/zora \\\n  -n zora-system \\\n  --version 0.9.2 \\\n  --create-namespace \\\n  --wait \\\n  --set clusterName=\"$(kubectl config current-context)\"\n</code></pre> <pre><code>helm upgrade --install zora oci://ghcr.io/undistro/helm-charts/zora \\\n  -n zora-system \\\n  --version 0.9.2 \\\n  --create-namespace \\\n  --wait \\\n  --set clusterName=\"$(kubectl config current-context)\"\n</code></pre> <p>This command will install Zora in <code>zora-system</code> namespace, creating the namespace if it doesn't already exist.</p> <p>Zora OSS + Zora Dashboard</p> <p>To integrate your Zora OSS installation with Zora Dashboard, you need to provide <code>saas.workspaceID</code> parameter in installation command.  For more information, please refer to this page.</p> <p>With the following commands, you can verify if Zora has been successfully installed and retrieve installation notes:</p> <pre><code>helm list -n zora-system\nhelm get notes zora -n zora-system\n</code></pre> <p>Zora Helm Chart</p> <p>To see the full list of available parameters in Zora Helm chart, please visit this page</p> <p>If everything is set up correctly, your cluster should have scheduled scans. Check it by running:</p> <pre><code>kubectl get cluster,scan -o wide -n zora-system\n</code></pre> <p>Customize scan schedule</p> <p>To customize the scan schedule, please refer to the Scan Schedule page.</p> <p>Once the cluster is successfully scanned, you can check issues by running:</p> <pre><code>kubectl get misconfigurations -n zora-system\nkubectl get vulnerabilities   -n zora-system\n</code></pre>"},{"location":"getting-started/installation/#migrating-to-08","title":"Migrating to 0.8","text":""},{"location":"getting-started/installation/#whats-new-in-08","title":"What's new in 0.8","text":""},{"location":"getting-started/installation/#extended-vulnerability-reports-information","title":"Extended Vulnerability Reports Information","text":"<p>Now, <code>VulnerabilityReports</code> provide more in-depth information about the image, including <code>OS</code>, <code>architecture</code>, <code>distro</code>, and <code>digest</code>. Additionally, details about vulnerabilities, such as <code>publishedDate</code> and <code>lastModifiedDate</code>, have been included  to offer a clearer understanding of your cluster's security posture.</p>"},{"location":"getting-started/installation/#full-integration-with-zora-dashboard","title":"Full Integration with Zora Dashboard","text":"<p>Zora 0.8 introduces the integration of Vulnerability Reports with the Zora Dashboard. Now, alongside misconfigurations, you can centrally explore images and vulnerabilities across your clusters.</p>"},{"location":"getting-started/installation/#migration-guide","title":"Migration guide","text":"<p>Version 0.7 or earlier</p> <p>If you are currently using a version prior to 0.7,  please be aware that the 0.7 release brought about significant architectural changes.  Before upgrading to version 0.8, refer to this page  for essential information and considerations to ensure a smooth transition.</p> <p>The recommended way to migrate to version 0.8 is to reinstall Zora, including its CRDs.</p>"},{"location":"getting-started/installation/#uninstall","title":"Uninstall","text":"<p>You can uninstall Zora and its components by uninstalling the Helm chart installed above.</p> <pre><code>helm uninstall zora -n zora-system\n</code></pre> <p>By design, Helm doesn't upgrade or delete CRDs. You can permanently delete Zora CRDs and any remaining associated resources from your cluster, using the following command.</p> <pre><code>kubectl get crd -o=name | grep --color=never 'zora.undistro.io' | xargs kubectl delete\n</code></pre> <p>You can also delete the <code>zora-system</code> namespace using the command below.</p> <pre><code>kubectl delete namespace zora-system\n</code></pre>"},{"location":"plugins/","title":"Zora Plugins","text":""},{"location":"plugins/#overview","title":"Overview","text":"<p>Zora utilizes open-source CLI tools like Marvin, Popeye,  and Trivy  as plugins to perform scans on Kubernetes clusters.</p> <p>The current available plugins of a Zora installation can be listed by running the following command:</p> <p><pre><code>kubectl get plugins -n zora-system\n</code></pre> <pre><code>NAME     IMAGE                               TYPE               AGE\nmarvin   ghcr.io/undistro/marvin:v0.2.1      misconfiguration   14m\npopeye   ghcr.io/undistro/popeye:0.21.3-6    misconfiguration   14m\ntrivy    ghcr.io/undistro/trivy:0.50.1-1     vulnerability      14m\n</code></pre></p> <p>Each item listed above is an instance of <code>Plugin</code> CRD and represents the execution configuration of a plugin. More details can be seen by getting the YAML output of a plugin: </p> <pre><code>kubectl get plugin marvin -o yaml -n zora-system\n</code></pre>"},{"location":"plugins/#plugin-types","title":"Plugin types","text":"<p>Currently, Zora has two plugin types: <code>vulnerability</code> and <code>misconfiguration</code>,  which determine the focus of plugin scans.</p> <ul> <li> <p><code>vulnerability</code> plugins scan cluster images for vulnerabilities,    and their results are stored as instances of <code>VulnerabilityReport</code> CRD.</p> </li> <li> <p><code>misconfiguration</code> plugins scan cluster resources for potential configuration issues,    and their results are available as instances of the <code>ClusterIssue</code> CRD.</p> </li> </ul> <p>Both result types can be listed using <code>kubectl</code>, and some aliases are supported for your convenience,  as shown in the following commands:</p> <p><pre><code>kubectl get vulnerabilityreports\nkubectl get vuln\nkubectl get vulns\nkubectl get vulnerabilities\n</code></pre> <pre><code>kubectl get clusterissues\nkubectl get issue\nkubectl get issues\nkubectl get misconfig\nkubectl get misconfigs\nkubectl get misconfigurations\n</code></pre></p> <p>Note</p> <p>The results are only available after a successful scan, in the same namespace as the <code>ClusterScan</code> (default is <code>zora-system</code>).</p>"},{"location":"plugins/#how-plugins-work","title":"How plugins work","text":"<p>Starting from a <code>Plugin</code> and a <code>ClusterScan</code>, Zora manages and schedules scans by applying <code>CronJobs</code>, which creates <code>Jobs</code> and <code>Pods</code>.</p> <p>The <code>Pods</code> where the scans run, include a \"sidecar\" container called worker alongside the plugin container.</p> <p>After the plugin completes its scan, it needs to signal to Zora (worker) by writing out the path of the results file  into a \"done file\".</p> <p>Worker container waits for the \"done file\" to be present,  then transforms the results and creates <code>ClusterIssues</code> and <code>VulnerabilityReports</code> (depending on the plugin type).</p> <p>Note</p> <p>This is the aspect that currently prevents the full declarative integration of new plugins.  The code responsible for transforming the output of each plugin into CRDs is written in Go within the worker.</p> <p>Any contributions or suggestions in this regard are greatly appreciated.</p> <p> </p> <p>Note</p> <p>This architecture for supporting plugins is inspired by Sonobuoy,  a project used for CNCF conformance certification.</p>"},{"location":"plugins/marvin/","title":"Marvin Plugin","text":"<p>Marvin is an open-source CLI tool that scans a Kubernetes cluster by performing CEL expressions  to report potential issues and misconfigurations.</p> <p>Marvin enables Zora's custom checks using CEL. For further information, please visit this page.</p> <p> Type: <code>misconfiguration</code></p> <p> Image: <code>ghcr.io/undistro/marvin:v0.2.1</code></p> <p> GitHub repository: https://github.com/undistro/marvin</p>"},{"location":"plugins/popeye/","title":"Popeye Plugin","text":"<p>Popeye is a utility that scans live Kubernetes cluster and reports potential issues with deployed resources and configurations.</p> <p> Type: <code>misconfiguration</code></p> <p> Image: <code>ghcr.io/undistro/popeye:0.21.3-6</code></p> <p> GitHub repository: https://github.com/derailed/popeye</p> <p>Info</p> <p>Currently, Zora does not use the official Popeye image (<code>derailed/popeye</code>) due to its lack of multi-architecture support.</p>"},{"location":"plugins/trivy/","title":"Trivy Plugin","text":"<p>Trivy is a versatile security scanner that can find vulnerabilities, misconfigurations, secrets, SBOM  in different targets like containers, code repositories and Kubernetes cluster.</p> <p>Zora uses Trivy as a plugin exclusively to scan vulnerabilities in a Kubernetes cluster.</p> <p> Type: <code>vulnerability</code></p> <p> Image: <code>ghcr.io/undistro/trivy:0.50.1-1</code></p> <p> GitHub repository: https://github.com/aquasecurity/trivy</p>"},{"location":"plugins/trivy/#vulnerability-database-persistence","title":"Vulnerability Database Persistence","text":"<p>Trivy utilizes a database containing vulnerability information.  This database is updated every 6 hours and persisted by default for caching purposes between the schedule scans.</p> <p>Please refer to this page for further details and  configuration options regarding vulnerability database persistence.</p>"},{"location":"plugins/trivy/#large-vulnerability-reports","title":"Large vulnerability reports","text":"<p>Vulnerability reports can be large. If you encounter issues with etcd request payload limit, you can ignore unfixed vulnerabilities from reports  by providing the following flag to <code>helm upgrade --install</code> command:</p> <pre><code>--set 'scan.plugins.trivy.ignoreUnfixed=true'\n</code></pre> <p>To identify this issue, check the logs of worker container in trivy pod. The <code>ClusterScan</code> will have a <code>Failed</code> status. You will see a log entry similar to the following example:</p> <pre><code>2023-09-26T14:18:02Z    ERROR   worker  failed to run worker    {\"error\": \"failed to create VulnerabilityReport \\\"kind-kind-usdockerpkgdevgooglesamplescontainersgkegbfrontendsha256dc8de8e0d569d2f828b187528c9317bd6b605c273ac5a282aebe471f630420fc-rzntw\\\": etcdserver: request is too large\"}\n</code></pre>"},{"location":"plugins/trivy/#scan-timeout","title":"Scan timeout","text":"<p>Trivy's scan duration may vary depending on the total images in your cluster  and the time to download the vulnerability database when needed. </p> <p>By default, Zora sets a timeout of 10 minutes for Trivy scan completion.</p> <p>To adjust this timeout, use the following Helm parameter:</p> <pre><code>--set scan.plugins.trivy.timeout=15m\n</code></pre> <p>Once this parameter is updated, the next scan will use the specified value.</p>"}]}